<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Brownian Motion Random Walk Visualization</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      background: #222;
      color: #eee;
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    h1 {
      margin-top: 32px;
      font-size: 2em;
    }
    #controls {
      margin: 20px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
      justify-content: center;
    }
    #controls label {
      margin-right: 8px;
      font-size: 1em;
    }
    #canvas-container {
      background: #111;
      border: 2px solid #444;
      border-radius: 8px;
      box-shadow: 0 0 16px #0008;
      margin-bottom: 32px;
    }
    canvas {
      display: block;
      background: #fff;
      border-radius: 6px;
    }
    .info {
      margin-bottom: 16px;
      color: #bbb;
      font-size: 0.95em;
      text-align: center;
      max-width: 650px;
    }
    button, input[type="range"], select {
      font-size: 1em;
    }
  </style>
</head>
<body>
  <h1>Brownian Motion Random Walk</h1>
  <div class="info">
    Visualizes 2D Brownian motion (random walk) with advanced features: multiple walkers, trails, adjustable speed, and step size. <br>
    Experiment with settings, pause, and resume. Ideal for educational and experimental purposes.
  </div>
  <div id="controls">
    <label>
      Walkers:
      <input type="number" id="numWalkers" min="1" max="100" value="1" style="width:60px;">
    </label>
    <label>
      Step size:
      <input type="range" id="stepSize" min="0.5" max="20" step="0.5" value="5">
      <span id="stepVal">5</span> px
    </label>
    <label>
      Speed:
      <input type="range" id="speed" min="1" max="120" step="1" value="60">
      <span id="speedVal">60</span> fps
    </label>
    <label>
      Trail length:
      <input type="range" id="trailLength" min="10" max="5000" step="10" value="500">
      <span id="trailVal">500</span>
    </label>
    <label>
      Color:
      <select id="colorMode">
        <option value="single">Single</option>
        <option value="multi">Multi</option>
        <option value="fade">Fade</option>
      </select>
    </label>
    <button id="pauseBtn">Pause</button>
    <button id="resetBtn">Reset</button>
  </div>
  <div id="canvas-container">
    <canvas id="walkCanvas" width="700" height="500"></canvas>
  </div>
  <div class="info">
    <strong>Tips:</strong> <br>
    - Switch to multiple walkers for interesting interactions.<br>
    - "Fade" color mode leaves a fading trail.<br>
    - "Reset" recenters all walkers.<br>
    - Adjust speed for slow-motion or fast-forward effects.
  </div>
  <script>
    const canvas = document.getElementById('walkCanvas');
    const ctx = canvas.getContext('2d');

    // Controls
    const numWalkersInput = document.getElementById('numWalkers');
    const stepSizeInput = document.getElementById('stepSize');
    const speedInput = document.getElementById('speed');
    const trailLengthInput = document.getElementById('trailLength');
    const colorModeInput = document.getElementById('colorMode');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const stepVal = document.getElementById('stepVal');
    const speedVal = document.getElementById('speedVal');
    const trailVal = document.getElementById('trailVal');

    // Parameters
    let numWalkers = parseInt(numWalkersInput.value);
    let stepSize = parseFloat(stepSizeInput.value);
    let speed = parseInt(speedInput.value);
    let trailLength = parseInt(trailLengthInput.value);
    let colorMode = colorModeInput.value;

    // Animation state
    let paused = false;
    let animationFrameId = null;
    let lastTimestamp = null;

    // Walker class
    class Walker {
      constructor(color) {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.color = color;
        this.trail = [{x: this.x, y: this.y}];
      }
      step() {
        const theta = Math.random() * 2 * Math.PI;
        this.x = Math.max(0, Math.min(canvas.width, this.x + Math.cos(theta) * stepSize));
        this.y = Math.max(0, Math.min(canvas.height, this.y + Math.sin(theta) * stepSize));
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > trailLength) this.trail.shift();
      }
      draw(trailOpacity = 0.2) {
        if (colorMode === 'fade') {
          ctx.strokeStyle = this.color;
          ctx.globalAlpha = 1.0;
          ctx.beginPath();
          for (let i = 1; i < this.trail.length; ++i) {
            ctx.globalAlpha = Math.max(0.05, (i / this.trail.length) * 0.8);
            ctx.moveTo(this.trail[i-1].x, this.trail[i-1].y);
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
          }
          ctx.stroke();
          ctx.globalAlpha = 1.0;
        } else {
          ctx.strokeStyle = this.color;
          ctx.globalAlpha = trailOpacity;
          ctx.beginPath();
          ctx.moveTo(this.trail[0].x, this.trail[0].y);
          for (let i = 1; i < this.trail.length; ++i) {
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
          }
          ctx.stroke();
          ctx.globalAlpha = 1.0;
        }
        // Draw walker
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 5, 0, 2*Math.PI);
        ctx.fill();
      }
      reset() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.trail = [{x: this.x, y: this.y}];
      }
    }

    let walkers = [];

    // Color helpers
    function randomColor() {
      // Vivid random color
      const h = Math.floor(Math.random() * 360);
      return `hsl(${h}, 85%, 55%)`;
    }

    function buildWalkers() {
      walkers = [];
      if (colorMode === 'single') {
        let col = '#2196f3';
        for (let i = 0; i < numWalkers; ++i) walkers.push(new Walker(col));
      } else if (colorMode === 'multi') {
        for (let i = 0; i < numWalkers; ++i) walkers.push(new Walker(randomColor()));
      } else if (colorMode === 'fade') {
        for (let i = 0; i < numWalkers; ++i) walkers.push(new Walker(randomColor()));
      }
    }

    function resetWalkers() {
      walkers.forEach(w => w.reset());
    }

    // Animation
    function clearCanvas() {
      if (colorMode === 'fade') {
        ctx.fillStyle = 'rgba(255,255,255,0.10)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
      } else {
        ctx.clearRect(0,0,canvas.width,canvas.height);
      }
    }

    function draw() {
      clearCanvas();
      let opacity = colorMode === 'multi' ? 0.18 : 0.28;
      walkers.forEach(walker => {
        walker.draw(opacity);
      });
    }

    function stepAll() {
      walkers.forEach(walker => walker.step());
    }

    function animate(timestamp) {
      if (!lastTimestamp) lastTimestamp = timestamp;
      const interval = 1000 / speed;
      if (timestamp - lastTimestamp >= interval) {
        stepAll();
        draw();
        lastTimestamp = timestamp;
      }
      if (!paused) {
        animationFrameId = requestAnimationFrame(animate);
      }
    }

    // Event listeners
    numWalkersInput.addEventListener('change', () => {
      numWalkers = Math.min(100, Math.max(1, parseInt(numWalkersInput.value)));
      buildWalkers();
      draw();
    });
    stepSizeInput.addEventListener('input', () => {
      stepSize = parseFloat(stepSizeInput.value);
      stepVal.textContent = stepSize;
    });
    speedInput.addEventListener('input', () => {
      speed = parseInt(speedInput.value);
      speedVal.textContent = speed;
    });
    trailLengthInput.addEventListener('input', () => {
      trailLength = parseInt(trailLengthInput.value);
      trailVal.textContent = trailLength;
      walkers.forEach(w => {
        if (w.trail.length > trailLength) w.trail = w.trail.slice(-trailLength);
      });
    });
    colorModeInput.addEventListener('change', () => {
      colorMode = colorModeInput.value;
      buildWalkers();
      draw();
    });
    pauseBtn.addEventListener('click', () => {
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
      if (!paused) {
        lastTimestamp = null;
        animate();
      } else {
        cancelAnimationFrame(animationFrameId);
      }
    });
    resetBtn.addEventListener('click', () => {
      resetWalkers();
      draw();
    });

    // Sync display values
    stepVal.textContent = stepSizeInput.value;
    speedVal.textContent = speedInput.value;
    trailVal.textContent = trailLengthInput.value;

    // Responsive canvas
    function fitCanvas() {
      // Maintain 7:5 aspect ratio
      let w = Math.min(window.innerWidth-24, 900);
      let h = Math.round(w * 5/7);
      if (h > window.innerHeight-200) {
        h = window.innerHeight-200;
        w = Math.round(h * 7/5);
      }
      canvas.width = w;
      canvas.height = h;
      resetWalkers();
      draw();
    }
    window.addEventListener('resize', fitCanvas);

    // Init
    buildWalkers();
    fitCanvas();
    draw();
    animate();
  </script>
</body>
</html>